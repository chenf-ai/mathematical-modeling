## 学习遗传算法&遗传算法在matlab中的具体实现

### 遗传算法概述

​		**遗传算法**源于生物学的启示，是模拟达尔文生物进化论的自然选择和遗传学机理的计算模型。该算法用于模拟自然进化过程从而搜索最优解。

​		在自然遗传学当中遗传算子会发生组合交叉、变异、遗传等行为，遗传算法往往会使用二进制编码将具体问题情境的参数进行转化，二进制编码即模拟对应自然遗传过程中的DNA，之后通过解的迭代来模拟自然遗传学当中遗传算子的行为。

### 遗传算法的实现步骤

+ **编码**

  ​		遗传算法的编码包括浮点编码和二进制编码两类，一般为了简化问题使用二进制编码。一般若参数的取值范围为$(L, U)$，使用长度为$k$的二进制编码对该参数进行表示，则共有$2^k$种不同的编码，该参数编码对应关系如下图所示

  ![](..\images_resources\Genetic-Algorithm-1.PNG)

  则对应的有
  $$
  \delta = \frac{U-L}{2^k- 1}
  $$

+ **解码**

  ​		解码操作将不直观的二进制数据传还原成十进制。设某一个体的二进制编码为$b_k b_{k-1}...b_3 b_2 b_1$，则对应的解码公式为
  $$
  x = L+ (\sum_{i = 1}^k b_i 2^{i-1})\frac{U-L}{2^k - 1}
  $$
  ​		遗传算法的编码和解码过程宏观上对应生物的基因型和表现型，微观上对应DNA的转录和翻译两个过程。

+ **个体适应度评估**

  + 个体适应度的评估分为如下的几个步骤

    1、首先进行解码，将二进制串转变为相应的个体真实值；

    2、评价目标函数$f(x^k)$，所谓的评价目标函数即将个体值代入求函数值；

    3、将目标函数值转为适应度，这里的转换具有可扩展性，对于极大值问题，目标函数值即可当作适应度。

  + 设计得到适应度的计算方式后，一般有如下的几个步骤

    1、计算所有染色体个体$U_k$（即二进制编码个体）的适应度值；

    2、计算种群的适应度总和，即将第一步求和即可
    $$
    F = \sum_{k = 1}^{pop_size}eval(U_k)
    $$
    3、计算每个染色体被复制的概率，计算方式为个体的适应度除以适应度总和，类似于归一化的操作
    $$
    P_k = \frac{eval(U_k)}{F}
    $$
    4、计算每个染色体被复制的累积概率，计算公式为
    $$
    Q_k = \sum_{j = 1}^k P_k
    $$
    ​		该特性类似于分布函数，意义在于，在实际操作时，产生一个随机数发现随机数所在的累积概率区间即可决定具体选择复制的染色体个体；换句话而言，该做法将$[0,1]$区间划分为了不同的部分，然后通过几何概型有概率随机选择。

+ **复制**

  ​		复制运算根据个体的适应度大小决定其下代遗传的可能性，个体适应度越高则复制的概率越大，而通过适应度中的归一化操作已经构造了适应度与概率之间的紧密关系。

  ​		具体而言，若种群当中有$N$个染色体个体，则往往会采用轮盘选择法转动$N$次轮盘。每次转动轮盘随机产生一个概率值（0到1之间的一个随机数），然后判断该随机数对于$[0,1]$的$Q_k$划分的所在区间，从而决定该轮次选择复制的染色体个体。

+ **交配**

  ​		“交配运算”时使用单点或多点进行交叉的算子。首先用随机数产生一个或多个交配点位置，然后两个个体在交配点位置互换部分基因码，形成两个子个体。简单而言，就是"123"与"xyz"可能交叉产生"12z"和"xy3"的逻辑，只是具体算法实现中交叉互换的时二进制编码，并且交换点需要另外随机确定。

  ​		算法具体实现“交配”的过程可参照如下步骤

  ​		**1、确定交叉染色体数量**

  ​		交配染色体的数量等于染色体总量乘以交配概率，在过程中会进行取整，可使用向下取整方法；例如，若染色体总量为10，交配概率为0.25，则参加交配的染色体数量为[2.5]条，即2条染色体进行交配。

  ​		**2、确定交配染色体对象**

  ​		考虑交配概率越低，复制概率低于交配概率的数量就越少，所以参加交配的染色体数量与交配概率可能会成正比。确定交配染色体对象的方法往往是从复制概率低于交配概率的个体中选择指定数量的染色体个体进行交配。

  ​		**3、进行交配**

  ​		交配的种类分为单点分配和多点分配，分配过程首先随机生成一个在二进制长度范围内的随机数，然后由随机数对应二进制串的位置，将位置右侧的编码内容进行替换即可完成两个个体之间的一次交配。

+ **突变**

  ​		“突变运算”使用基本位进行基因突变，其作用可以在某种程度上防止算法在迭代后期过早收敛。表现为二进制编码层面，即对基因码进行小几率翻转（0-1替换）。

  ​		具体实现时，设定基因突变的概率参数，每个染色体的突变概率相同，即此时对于基因突变不考虑复制概率的影响。在实现时，设置一个很小的基因突变概率值，例如0.01；然后从编码的每个二进制位进行考虑，例如有10个染色体，每个个体的二进制长度位33，则有330个二进制位，为每一个二进制位生成一个0-1范围的随机数，然后根据生成的随机数，选择其中小于突变概率的数据，将对应的二进制位进行翻转。

+ **倒位**

  ​		从遗传学角度来看，倒位是指某一区段染色体发生180度颠倒的现象，染色体的倒位在生物学角度上可能会导致“生殖隔离”。从算法角度来看，倒位与突变的实现并没有过大的差别，对于一些复杂的问题可能会尝试使用“倒位”进行处理。

### 遗传算法特点

+ 遗传算法本质上属于一种启发式的随机搜索算法，所以由遗传算法得出的结果每次都不相同（参照**Intro of AI**课程进行理解）。
+ 自变量在给定的约束条件下进行了无缝编码（即这种编码方式能够表达解空间中的所有可行解），所以从理论上而言，遗传算法有机会能够到达全局最优解。

----

### 遗传算法的程序设计伪代码

```matlab
BEGIN
	t = 0;                  
	初始化P(t);    
    计算P(t)的适应值;
    while(不满足停止准则) do
    	begin
    	t = t + 1;
    	从P(t-1)中选择P(t);
    	重组P(t);
    	计算P(t)的适应值;
    	end
  	END
```

----

### 遗传算法参数设计原则

+ 关于种群的规模

  ​		若种群规模太小，容易出现近亲交配导致病态基因，而且会造成有效等位基因先天缺乏，即使采用较大概率的变异算子，进行有效进化的可能性仍较小，并且大概率变异算子对于已有模式的破坏作用较大；而如果种群规模过大，则算法难以收敛，容易导致资源的浪费。建议种群规模在0~100范围。

+ 变异概率

  ​		若变异概率太小，种群的多样性下降太快，容易导致有效基因的迅速丢失且不容易修补；当变异概率太大时，尽管种群的多样性可以得到保证，但是高阶模式被破坏的概率也随之增大。变异概率一般取0.0001~0.2。

+ 交配概率

  ​		交配概率和变异概率类似，太大大小都不合适，一般取0.4~0.99。

+ 进化代数

  ​		进化代数太小算法不容易收敛，太大则容易造成时间开支和资源浪费，一般进化代数取100~500。当然可额外设置进化迭代的终止条件。

+ 种群初始化

  ​		初始种群的生成是随机的。但初始种群会影响到全局最优解的取得，因而往往会首先进行一个大概的区间估计。

+ 关于适应度函数的调整

  ​		在遗传算法的初期阶段，避免陷入局部最优解出现早熟现象，往往会对一些适应度较高的个体进行控制，降低其适应度与其他个体适应度之间的差异程度，从而减少其复制数量。

  ​		在遗传算法的后期阶段，大部分个体的适应度和最佳个体的适应度差异不大，之间无竞争力可言，这将导致无法对某些重点区域进行重点搜索，从而影响遗传算法的运行效率；故而在后期会适当放大个体之间适应度的差异。

----

### matlab中有关遗传算法的工具库

+ **函数ga**

  ga函数是matlab GA Toolbox的核心函数，其语法格式为

  ```matlab
  [x,fval,reason] = ga(@fitnessfun,nvars,options)
  ```

  相关参数含义如下

  > @x:	经过遗传算法求解后得到的自变量最佳染色体返回值。
  >
  > @fval:	最佳染色体的适应度值。
  >
  > @reason:	算法停止原因。
  >
  > @[@]fitnessfun:	适应度句柄函数。
  >
  > @nvars:	目标函数参数个数。
  >
  > @options:	算法的属性设定，该属性通过函数gaoptimset函数设置。

+ **函数gaoptimset**

  函数gaoptimset的语法格式为

  ```matlab
  options = gaoptimset('PropertyName1','PropertyValue1',
  'PropertyName 2','PropertyValue 2','PropertyName 3','PropertyValue 3',...)
  ```

  相关属性设置如下

  |      属性名       | 默认值 | 实现功能                     |
  | :---------------: | :----: | :--------------------------- |
  |   PopInitRange    | [0,1]  | 初始种群生成区间             |
  |  PopulationSize   |   20   | 种群规模                     |
  | CrossoverFraction |  0.8   | 交配概率                     |
  | MigrationFraction |  0.2   | 变异概率                     |
  |    Generations    |  100   | 超过进化代数算法停止         |
  |     TimeLimit     |  Inf   | 超过时间上限则算法停止       |
  |   FitnessLimit    |  -Inf  | 最佳$\l$适应度阈值则算法停止 |
  |   StallGenLimit   |   50   | 超过连续代数不进化则算法停止 |
  |  StallTimeLimit   |   20   | 超过连续时间不进化则算法停止 |
  | InitialPopulation |  [  ]  | 初始化种群                   |
  |     PlotFcns      |  [  ]  | 绘图函数，例@gaplotbestf     |

+ **一种做法**

  ​		遗传算法本质是随机算法，算法程序往往需要运行多次才能得到理想结果。一种常见的做法是将前一次运行得到的最后种群作为下一次运行的初始种群，以期望获得更好的结果。

  ```matlab
  [x,fval,reason,output,final_pop] = ga(@fitnessfcn,nvars);
  options = gaoptimset('InitialPopulation',finnal_pop);
  [x,fval,reason,output,final_pop2] = ga(@fitnessfcn,nvars,options);
  ```

+ **Genetic Algorithm and Direct Search Toolbox适应度函数设计**

  ​		首先遗传算法和直接搜索工具箱中的函数ga是求解目标函数的最小值，根据该特点，从目标函数出发设计适应度函数，下面列出几种基本情况。

  1、目标函数为求解最小值问题

  ​		当目标函数为求解最小值问题时，可以直接令目标函数为适应度函数，相应语法格式如下：

  ```matlab
  function f = fitnessfcn(x)	% x为自变量向量
  f = f(x);
  ```

  2、如果存在约束条件，包括但不限于自变量的取值范围，对于求解函数的最小值问题，可以使用如下语法格式：

  ```matlab
  function f = fitnessfcn(x)
  if (x <= -1|x > 3)	% 表示有约束x > -1和x <= 3,其他约束条件类推
  	f = inf;
  else
  	f = f(x);
  end
  ```

  3、如果存在约束条件（包括自变量的取值范围），对于求解函数的最大值问题，可以使用如下语法格式：
  
  ```matlab
  function f = fitnessfcn(x)
  if (x <= -1 | x > 3)
  	f = inf;
  else
  	f = -f(x);		% 注意，这里f = -f(x)而不是f = f(x)
  end
  ```
  
  






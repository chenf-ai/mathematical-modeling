## 学习遗传算法&遗传算法在matlab中的具体实现

### 遗传算法概述

​		**遗传算法**源于生物学的启示，是模拟达尔文生物进化论的自然选择和遗传学机理的计算模型。该算法用于模拟自然进化过程从而搜索最优解。

​		在自然遗传学当中遗传算子会发生组合交叉、变异、遗传等行为，遗传算法往往会使用二进制编码将具体问题情境的参数进行转化，二进制编码即模拟对应自然遗传过程中的DNA，之后通过解的迭代来模拟自然遗传学当中遗传算子的行为。

### 遗传算法的实现步骤

+ **编码**

  ​		遗传算法的编码包括浮点编码和二进制编码两类，一般为了简化问题使用二进制编码。一般若参数的取值范围为$(L, U)$，使用长度为$k$的二进制编码对该参数进行表示，则共有$2^k$种不同的编码，该参数编码对应关系如下图所示

  ![](..\images_resources\Genetic-Algorithm-1.PNG)

  则对应的有
  $$
  \delta = \frac{U-L}{2^k- 1}
  $$

+ **解码**

  ​		解码操作将不直观的二进制数据传还原成十进制。设某一个体的二进制编码为$b_k b_{k-1}...b_3 b_2 b_1$，则对应的解码公式为
  $$
  x = L+ (\sum_{i = 1}^k b_i 2^{i-1})\frac{U-L}{2^k - 1}
  $$
  ​		遗传算法的编码和解码过程宏观上对应生物的基因型和表现型，微观上对应DNA的转录和翻译两个过程。

+ **个体适应度评估**

  + 个体适应度的评估分为如下的几个步骤

    1、首先进行解码，将二进制串转变为相应的个体真实值；

    2、评价目标函数$f(x^k)$，所谓的评价目标函数即将个体值代入求函数值；

    3、将目标函数值转为适应度，这里的转换具有可扩展性，对于极大值问题，目标函数值即可当作适应度。

  + 设计得到适应度的计算方式后，一般有如下的几个步骤

    1、计算所有染色体个体$U_k$（即二进制编码个体）的适应度值；

    2、计算种群的适应度总和，即将第一步求和即可
    $$
    F = \sum_{k = 1}^{pop_size}eval(U_k)
    $$
    3、计算每个染色体被复制的概率，计算方式为个体的适应度除以适应度总和，类似于归一化的操作
    $$
    P_k = \frac{eval(U_k)}{F}
    $$
    4、计算每个染色体被复制的累积概率，计算公式为
    $$
    Q_k = \sum_{j = 1}^k P_k
    $$
    ​		该特性类似于分布函数，意义在于，在实际操作时，产生一个随机数发现随机数所在的累积概率区间即可决定具体选择复制的染色体个体；换句话而言，该做法将$[0,1]$区间划分为了不同的部分，然后通过几何概型有概率随机选择。

+ **复制**

  ​		复制运算根据个体的适应度大小决定其下代遗传的可能性，个体适应度越高则复制的概率越大，而通过适应度中的归一化操作已经构造了适应度与概率之间的紧密关系。

  ​		具体而言，若种群当中有$N$个染色体个体，则往往会采用轮盘选择法转动$N$次轮盘。每次转动轮盘随机产生一个概率值（0到1之间的一个随机数），然后判断该随机数对于$[0,1]$的$Q_k$划分的所在区间，从而决定该轮次选择复制的染色体个体。

+ **交配**

  ​		“交配运算”时使用单点或多点进行交叉的算子。首先用随机数产生一个或多个交配点位置，然后两个个体在交配点位置互换部分基因码，形成两个子个体。简单而言，就是"123"与"xyz"可能交叉产生"12z"和"xy3"的逻辑，只是具体算法实现中交叉互换的时二进制编码，并且交换点需要另外随机确定。

  ​		算法具体实现“交配”的过程可参照如下步骤

  ​		**1、确定交叉染色体数量**

  ​		交配染色体的数量等于染色体总量乘以交配概率，在过程中会进行取整，可使用向下取整方法；例如，若染色体总量为10，交配概率为0.25，则参加交配的染色体数量为[2.5]条，即2条染色体进行交配。

  ​		**2、确定交配染色体对象**

  ​		考虑交配概率越低，复制概率低于交配概率的数量就越少，所以参加交配的染色体数量与交配概率可能会成正比。确定交配染色体对象的方法往往是从复制概率低于交配概率的个体中选择指定数量的染色体个体进行交配。

  ​		**3、进行交配**

  ​		交配的种类分为单点分配和多点分配，分配过程首先随机生成一个在二进制长度范围内的随机数，然后由随机数对应二进制串的位置，将位置右侧的编码内容进行替换即可完成两个个体之间的一次交配。

+ **突变**

  ​		“突变运算”使用基本位进行基因突变，其作用可以在某种程度上防止算法在迭代后期过早收敛。表现为二进制编码层面，即对基因码进行小几率翻转（0-1替换）。

  ​		具体实现时，设定基因突变的概率参数，每个染色体的突变概率相同，即此时对于基因突变不考虑复制概率的影响。在实现时，设置一个很小的基因突变概率值，例如0.01；然后从编码的每个二进制位进行考虑，例如有10个染色体，每个个体的二进制长度位33，则有330个二进制位，为每一个二进制位生成一个0-1范围的随机数，然后根据生成的随机数，选择其中小于突变概率的数据，将对应的二进制位进行翻转。

+ **倒位**

  ​		从遗传学角度来看，倒位是指某一区段染色体发生180度颠倒的现象，染色体的倒位在生物学角度上可能会导致“生殖隔离”。从算法角度来看，倒位与突变的实现并没有过大的差别，对于一些复杂的问题可能会尝试使用“倒位”进行处理。

### 遗传算法特点

+ 遗传算法本质上属于一种启发式的随机搜索算法，所以由遗传算法得出的结果每次都不相同（参照**Intro of AI**课程进行理解）。
+ 自变量在给定的约束条件下进行了无缝编码（即这种编码方式能够表达解空间中的所有可行解），所以从理论上而言，遗传算法有机会能够到达全局最优解。

  